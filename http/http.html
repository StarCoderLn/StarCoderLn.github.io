<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP 的请求模型 | 鸵鸟蛋的个人主页</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/image/logo.jpg">
    <meta name="description" content="鸵鸟蛋的世界">
    <link rel="preload" href="/assets/css/0.styles.22095322.css" as="style"><link rel="preload" href="/assets/js/app.83f3402d.js" as="script"><link rel="preload" href="/assets/js/2.a0a69aa9.js" as="script"><link rel="preload" href="/assets/js/9.698ca62a.js" as="script"><link rel="prefetch" href="/assets/js/10.439f342d.js"><link rel="prefetch" href="/assets/js/11.216a07f2.js"><link rel="prefetch" href="/assets/js/12.a66aca6c.js"><link rel="prefetch" href="/assets/js/13.f5f24ce3.js"><link rel="prefetch" href="/assets/js/14.32d895c9.js"><link rel="prefetch" href="/assets/js/15.623a8373.js"><link rel="prefetch" href="/assets/js/16.31912b5c.js"><link rel="prefetch" href="/assets/js/17.68031807.js"><link rel="prefetch" href="/assets/js/18.a66b9dd4.js"><link rel="prefetch" href="/assets/js/19.c3c1ad4e.js"><link rel="prefetch" href="/assets/js/20.67c9540c.js"><link rel="prefetch" href="/assets/js/21.722fe9fe.js"><link rel="prefetch" href="/assets/js/22.72f8f629.js"><link rel="prefetch" href="/assets/js/23.f730e8f1.js"><link rel="prefetch" href="/assets/js/24.9e67058b.js"><link rel="prefetch" href="/assets/js/25.81a3aeea.js"><link rel="prefetch" href="/assets/js/26.18ba7257.js"><link rel="prefetch" href="/assets/js/27.eee6c364.js"><link rel="prefetch" href="/assets/js/28.d2732972.js"><link rel="prefetch" href="/assets/js/29.d54fb216.js"><link rel="prefetch" href="/assets/js/3.8959ecef.js"><link rel="prefetch" href="/assets/js/30.e71f561f.js"><link rel="prefetch" href="/assets/js/31.4f56f5c3.js"><link rel="prefetch" href="/assets/js/32.4ecd4417.js"><link rel="prefetch" href="/assets/js/33.32d721bd.js"><link rel="prefetch" href="/assets/js/34.ab789bed.js"><link rel="prefetch" href="/assets/js/35.e2330e74.js"><link rel="prefetch" href="/assets/js/36.a4d7a3e2.js"><link rel="prefetch" href="/assets/js/37.ca9e6d12.js"><link rel="prefetch" href="/assets/js/38.8e7d9dae.js"><link rel="prefetch" href="/assets/js/39.818446de.js"><link rel="prefetch" href="/assets/js/4.bc08363f.js"><link rel="prefetch" href="/assets/js/40.6e5412c0.js"><link rel="prefetch" href="/assets/js/41.c046cc2c.js"><link rel="prefetch" href="/assets/js/42.3a98e5b0.js"><link rel="prefetch" href="/assets/js/43.c48084fd.js"><link rel="prefetch" href="/assets/js/44.9a68e6e8.js"><link rel="prefetch" href="/assets/js/45.607f9d7b.js"><link rel="prefetch" href="/assets/js/46.4fbd5727.js"><link rel="prefetch" href="/assets/js/47.ff6cd126.js"><link rel="prefetch" href="/assets/js/48.4e44b645.js"><link rel="prefetch" href="/assets/js/49.b3559737.js"><link rel="prefetch" href="/assets/js/5.247f2124.js"><link rel="prefetch" href="/assets/js/50.4c05ad25.js"><link rel="prefetch" href="/assets/js/51.27325a7b.js"><link rel="prefetch" href="/assets/js/52.62b7f674.js"><link rel="prefetch" href="/assets/js/53.fe6c2e96.js"><link rel="prefetch" href="/assets/js/54.68c91b01.js"><link rel="prefetch" href="/assets/js/55.a4e116a4.js"><link rel="prefetch" href="/assets/js/56.adec72d4.js"><link rel="prefetch" href="/assets/js/57.c8755c55.js"><link rel="prefetch" href="/assets/js/58.99e5de2f.js"><link rel="prefetch" href="/assets/js/59.f7deea0d.js"><link rel="prefetch" href="/assets/js/6.9cd44cad.js"><link rel="prefetch" href="/assets/js/60.608e9336.js"><link rel="prefetch" href="/assets/js/7.d1cbdc31.js"><link rel="prefetch" href="/assets/js/8.3e9a3d41.js">
    <link rel="stylesheet" href="/assets/css/0.styles.22095322.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">鸵鸟蛋的个人主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://starcoderln.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  主页
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://www.github.com/StarCoderLn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://starcoderln.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  主页
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://www.github.com/StarCoderLn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VuePress</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>服务器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Nginx</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>PHP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>函数式编程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面向切面编程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node.js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>HTTP</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/http/http.html" class="active sidebar-link">HTTP 协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/http/http.html#http-的请求模型" class="sidebar-link">HTTP 的请求模型</a></li><li class="sidebar-sub-header"><a href="/http/http.html#浏览器请求资源的处理流程" class="sidebar-link">浏览器请求资源的处理流程</a></li><li class="sidebar-sub-header"><a href="/http/http.html#什么是-http-协议" class="sidebar-link">什么是 HTTP 协议</a></li><li class="sidebar-sub-header"><a href="/http/http.html#tcp-ip-协议栈" class="sidebar-link">TCP/IP 协议栈</a></li><li class="sidebar-sub-header"><a href="/http/http.html#tcp-协议数据传输过程" class="sidebar-link">TCP 协议数据传输过程</a></li><li class="sidebar-sub-header"><a href="/http/http.html#tcp-协议模型详解" class="sidebar-link">TCP 协议模型详解</a></li><li class="sidebar-sub-header"><a href="/http/http.html#tcp-三次握手和四次挥手" class="sidebar-link">TCP 三次握手和四次挥手</a></li><li class="sidebar-sub-header"><a href="/http/http.html#http-的工作过程" class="sidebar-link">HTTP 的工作过程</a></li><li class="sidebar-sub-header"><a href="/http/http.html#http-的请求与响应" class="sidebar-link">HTTP 的请求与响应</a></li><li class="sidebar-sub-header"><a href="/http/http.html#http-的请求方法" class="sidebar-link">HTTP 的请求方法</a></li><li class="sidebar-sub-header"><a href="/http/http.html#http-状态码" class="sidebar-link">HTTP 状态码</a></li><li class="sidebar-sub-header"><a href="/http/http.html#cookie-与-session" class="sidebar-link">Cookie 与 Session</a></li><li class="sidebar-sub-header"><a href="/http/http.html#http-的缓存机制" class="sidebar-link">HTTP 的缓存机制</a></li></ul></li><li><a href="/http/cryptography.html" class="sidebar-link">密码学入门</a></li><li><a href="/http/http2.html" class="sidebar-link">HTTPS、HTTP2、HTTP3</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端监控</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法学习总结</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mac 开发体验优化</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="http-的请求模型"><a href="#http-的请求模型" class="header-anchor">#</a> HTTP 的请求模型</h2> <p>HTTP 的请求模型很简单，但是其中的实现却有许多具体细节。</p> <p><img src="/assets/img/http1.857a1e7e.png" alt="http" title="http"></p> <h2 id="浏览器请求资源的处理流程"><a href="#浏览器请求资源的处理流程" class="header-anchor">#</a> 浏览器请求资源的处理流程</h2> <ol><li><p>输入网址并回车</p></li> <li><p>解析域名</p></li> <li><p>浏览器发送 HTTP 请求</p></li> <li><p>服务器处理请求</p></li> <li><p>服务器返回 HTML 响应</p></li> <li><p>浏览器处理 HTML 页面</p></li> <li><p>继续请求其他资源</p></li></ol> <p><img src="/assets/img/http2.dca1842c.png" alt="http" title="http"></p> <h2 id="什么是-http-协议"><a href="#什么是-http-协议" class="header-anchor">#</a> 什么是 HTTP 协议</h2> <ol><li><p>HTTP 是<strong>超文本传输协议</strong>，从 www 浏览器传输到本地浏览器的一种传输协议，网站是基于 HTTP 协议的，例如网站的图片、CSS、JS 等都是基于 HTTP 协议进行传输的。</p></li> <li><p>HTTP 协议是对由从客户机到服务器的请求(Request)和从服务器到客户机的响应(response)进行<strong>约束</strong>和<strong>规范</strong>。</p></li></ol> <p><img src="/assets/img/http3.49801806.png" alt="http" title="http"></p> <ul><li><p>HTTP/1.0 的出现意味着 HTTP 协议成熟了，HTTP/1.1 的出现意味着 HTTP/1 协议已经很完善了。</p></li> <li><p>在 HTTP/2 之后还有 HTTP/3，HTTP/3 相对于前两者来说是一种全新的协议，它把底层的协议给换了。前两者底层的协议是 TCP，而 HTTP/3 把底层协议换成了 UDP 协议。</p></li></ul> <ol start="3"><li>HTTP 协议的官方文档非常的晦涩难懂，而且枯燥。如果想学习协议的话，可以去看 <a href="http://www.cnpaf.net/class/RFC/" target="_blank" rel="noopener noreferrer">中文 RFC 文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，<a href="http://www.cnpaf.net/Class/HTTP/" target="_blank" rel="noopener noreferrer">HTTP 协议<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li></ol> <h2 id="tcp-ip-协议栈"><a href="#tcp-ip-协议栈" class="header-anchor">#</a> TCP/IP 协议栈</h2> <p>📌 <strong>1. OSI 七层模型（ISO 协议），从上到下分别如下。</strong></p> <ul><li><p>应用层</p></li> <li><p>表示层</p></li> <li><p>会话层</p></li> <li><p>传输层</p></li> <li><p>网络层</p></li> <li><p>数据链路层</p></li> <li><p>物理层</p></li></ul> <p>📌 <strong>2. TCP/IP 四层模型，从上到下分别如下。</strong></p> <ul><li><p>应用层</p></li> <li><p>传输层</p></li> <li><p>网络层</p></li> <li><p>网络接口层</p></li></ul> <p><strong>也有的是把 TCP/IP 分成了五层模型，其实是差不多的。</strong></p> <ul><li><p>应用层</p></li> <li><p>传输层</p></li> <li><p>网络层</p></li> <li><p>数据链路层</p></li> <li><p>物理层</p></li></ul> <p>📌 <strong>3. TCP/IP 四层模型每层的作用。</strong></p> <ul><li><p>应用层</p> <p>为用户提供所需要的各种服务，例如：<strong>HTTP</strong>、<strong>FTP</strong>、<strong>DNS</strong>、<strong>SMTP</strong>、<strong>SSH</strong>、<strong>TELNET</strong>、<strong>POP3</strong> 等。</p></li> <li><p>传输层</p> <p>为应用层实体提供端到端的通信功能，保证数据包的顺序传送及数据的完整性。</p> <p>该层定义了两个主要的协议：<strong>传输控制协议(TCP)<strong>和</strong>用户数据报协议(UDP)</strong>。</p> <p><strong>TCP 是面向连接的协议，UDP 是无连接的协议。</strong></p></li> <li><p>网络层</p> <p>主要解决主机到主机的通信问题。<strong>IP 协议是网际互联层最重要的协议</strong>。</p> <p>当我们去 ping 一个网址的时候，用到的协议是 <strong>ICMP 协议</strong>，这个协议也在网络层中。</p> <p>该层也叫做 <strong>IP 层</strong>。</p></li> <li><p>网络接口层</p> <p>负责监视数据在主机和网络之间的交换。</p></li></ul> <p>发送数据的时候是一层一层往下传的，接收数据的时候是一层一层往上传的。</p> <p>📌 <strong>4. HTTP 和 HTTPS 在 TCP/IP 协议栈中的位置</strong></p> <p><img src="/assets/img/http4.10f662ef.png" alt="http" title="http"></p> <ul><li><p>目前普遍应用的版本是 HTTP/1.1，正在逐步向 HTTP/2.0 迁移。</p></li> <li><p>HTTP 的默认端口是<code>80</code>，HTTPS 的默认端口是<code>443</code>。</p></li> <li><p>HTTP/1.1 和 HTTP/1.0 之间的区别就是，新增了 <strong>Keep-Alive</strong>（长连接）特性。</p></li></ul> <h2 id="tcp-协议数据传输过程"><a href="#tcp-协议数据传输过程" class="header-anchor">#</a> TCP 协议数据传输过程</h2> <p><img src="/assets/img/http15.67baa7b0.png" alt="http" title="http"></p> <p>TCP 这一层对数据的封装如下。TCP 传输数据时，<strong>是把一个大数据包切成若干个小数据包进行发送的，这些小数据包根据 Sequence Number 进行排序，等到了接收方那里再根据各自的 Sequence Number 重新组装起来</strong>，这样的话能提高传输效率。</p> <p><img src="/assets/img/http17.53bc5fbf.png" alt="http" title="http"></p> <h2 id="tcp-协议模型详解"><a href="#tcp-协议模型详解" class="header-anchor">#</a> TCP 协议模型详解</h2> <table><thead><tr><th>OSI 中的层</th> <th>功能</th> <th>TCP/IP 协议族</th></tr></thead> <tbody><tr><td>应用层</td> <td>文件传输，电子邮件，文件服务，虚拟终端</td> <td>TFTP，HTTP，SNMP，FTP，SMTP，DNS，TELNET</td></tr> <tr><td>表示层</td> <td>数据格式化，代码转换，数据加密</td> <td>没有协议</td></tr> <tr><td>会话层</td> <td>解除或建立与别的节点的联系</td> <td>没有协议</td></tr> <tr><td>传输层</td> <td>提供端对端的接口</td> <td>TCP，UDP</td></tr> <tr><td>网络层</td> <td>为数据包选择路由</td> <td>IP，ICMP，RIP，OSPF，BGP，IGMP</td></tr> <tr><td>数据链路层</td> <td>传输有地址的帧以及错误检测功能</td> <td>SLIP，CSLIP，PPP，ARP，RARP，MTU</td></tr> <tr><td>物理层</td> <td>以二进制数据形式在物理媒体上传输数据</td> <td>ISO2110，IEEE802，IEEE802.2</td></tr></tbody></table> <h2 id="tcp-三次握手和四次挥手"><a href="#tcp-三次握手和四次挥手" class="header-anchor">#</a> TCP 三次握手和四次挥手</h2> <p><img src="/assets/img/http18.87a27ee9.png" alt="http" title="http"></p> <div class="custom-block tip"><p class="custom-block-title">补充</p> <ol><li><p>正常状态下，数据传输完成后，都是由客户端来断开连接；非正常状态下，如果客户端一直没有传输数据，服务器端也会自己断开连接。</p></li> <li><p>当客户端发送 FIN 请求断开连接时，此时客户端就没法再发送有效数据了，但是可以继续发送请求命令。</p></li> <li><p>图中像 SYN_SENT 等这些状态，在 mac 或者 linux 上可以通过 <code>netstat -an</code> 命令查看。</p></li> <li><p>TCP 协议端口状态说明。</p></li></ol> <ul><li><strong>LISTENING</strong></li></ul> <p>提供某种服务，侦听远方 TCP 端口的连接请求，当提供的服务没有被连接时，处于 LISTENING 状态，端口是开放的，等待被连接。</p> <ul><li><strong>SYN_SENT (客户端状态)</strong></li></ul> <p>客户端调用 connect，发送一个 SYN 请求建立一个连接，在发送连接请求后等待匹配的连接请求，此时状态为 SYN_SENT。</p> <ul><li><strong>SYN_RCVD (服务端状态)</strong></li></ul> <p>在收到和发送一个连接请求后，等待对方对连接请求的确认，当服务器收到客户端发送的同步信号时，将标志位 ACK 和 SYN 置1发送给客户端，此时服务器端处于 SYN_RCVD 状态，如果连接成功了就变为 ESTABLISHED，正常情况下 SYN_RCVD 状态非常短暂。</p> <ul><li><strong>ESTABLISHED</strong></li></ul> <p>ESTABLISHED 状态是表示两台机器正在传输数据。</p> <ul><li><strong>FIN_WAIT_1</strong></li></ul> <p>等待远程 TCP 连接中断请求，或先前的连接中断请求的确认，主动关闭端应用程序调用 close，TCP 发出 FIN 请求主动关闭连接，之后进入 FIN_WAIT_1 状态。</p> <ul><li><strong>FIN_WAIT_2</strong></li></ul> <p>从远程 TCP 等待连接中断请求，主动关闭端接到 ACK 后，就进入了 FIN_WAIT_2。这是在关闭连接时，客户端和服务器两次握手之后的状态，是著名的半关闭的状态了，在这个状态下，应用程序还有接受数据的能力，但是已经无法发送数据，但是也有一种可能是，客户端一直处于 FIN_WAIT_2 状态，而服务器则一直处于 WAIT_CLOSE 状态，而直到应用层来决定关闭这个状态。</p> <ul><li><strong>CLOSE_WAIT</strong></li></ul> <p>等待从本地用户发来的连接中断请求，被动关闭端 TCP 接到 FIN 后，就发出 ACK 以回应 FIN 请求(它的接收也作为文件结束符传递给上层应用程序)，并进入CLOSE_WAIT。</p> <ul><li><strong>CLOSING</strong></li></ul> <p>等待远程 TCP 对连接中断的确认，处于此种状态比较少见。</p> <ul><li><strong>LAST_ACK</strong></li></ul> <p>等待原来的发向远程 TCP 的连接中断请求的确认，被动关闭端一段时间后，接收到文件结束符的应用程序将调用 close 关闭连接，TCP 也发送一个 FIN，等待对方的 ACK，进入 LAST_ACK。</p> <ul><li><strong>TIME_WAIT</strong></li></ul> <p>在主动关闭端接收到 FIN 后，TCP 就发送 ACK 包，并进入 TIME_WAIT 状态，等待足够的时间以确保远程 TCP 接收到连接中断请求的确认，很大程度上保证了双方都可以正常结束，但是也存在问题，须等待 2MSL 时间的过去才能进行下一次连接。</p> <ul><li><strong>CLOSED</strong></li></ul> <p>被动关闭端在接受到 ACK 包后，就进入了 CLOSED 的状态，连接结束，没有任何连接状态。</p></div> <h2 id="http-的工作过程"><a href="#http-的工作过程" class="header-anchor">#</a> HTTP 的工作过程</h2> <p>一次 HTTP 操作（一个请求和一个响应）称为一个<strong>事务</strong>，其工作过程可分为四步:</p> <ol><li><p>首先客户机与服务器需要<strong>建立 TCP 连接</strong>。只要单击某个超级链接，HTTP 的工作开始。</p></li> <li><p>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：<strong>统一资源标识符(URL)</strong>、<strong>协议版本号</strong>，后边是 <strong>MIME 信息，包括请求修饰符、客户机信息和可能的内容</strong>。</p></li> <li><p>服务器接到请求后，给予相应的响应信息，其格式为一个<strong>状态行</strong>，包括<strong>信息的协议版本号</strong>、<strong>一个成功或错误的代码</strong>，后边是 <strong>MIME 信息包括服务器信息、实体信息和可能的内容</strong>。</p></li> <li><p>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器<strong>断开 TCP 连接</strong>。</p></li></ol> <p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，由显示屏输出。对于用户来说，这些过程是由 HTTP 自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p> <div class="custom-block tip"><p class="custom-block-title">事务</p> <p>所谓事务，就是有一个任务或操作，我们无法一次性完成，它包含若干个步骤，这些步骤相互之间有依赖性，当然有些步骤之间也有可能没有依赖性，像这样的任务或操作就叫做事务。</p> <p>事务的特点就是，如果其中某个步骤失败了，那么依赖它的其他步骤也就无法执行，那么就认为这整个事务就失败了。而且，事务可以回滚。</p> <p>数据库里就有事务，但是，事务并不是数据库专有的，在很多地方都有用到事务。</p> <p>HTTP 工作过程的回滚不是我们常见的那种可以看到的回滚，比如关闭连接，释放内存等。</p></div> <h2 id="http-的请求与响应"><a href="#http-的请求与响应" class="header-anchor">#</a> HTTP 的请求与响应</h2> <ol><li><p>HTTP请求组成：<strong>请求行</strong>、<strong>消息报头</strong>、<strong>请求正文</strong>。</p></li> <li><p>HTTP响应组成：<strong>状态行</strong>、<strong>消息报头</strong>、<strong>响应正文</strong>。</p></li> <li><p>请求行组成：以一个方法符号开头，后面跟着请求的 URL 和协议的版本。</p></li> <li><p>状态行组成：服务器 HTTP 协议的版本，服务器发回的响应状态代码和状态代码的文本描述。</p></li></ol> <ul><li>HTTP 请求报文</li></ul> <p><img src="/assets/img/http6.280b63e0.png" alt="http" title="http"></p> <p><a href="http://www.asciima.com/ascii/12.html" target="_blank" rel="noopener noreferrer">ASCII 码表<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li>HTTP 请求报文例子</li></ul> <p><img src="/assets/img/http5.02f37884.png" alt="http" title="http"></p> <ul><li>HTTP 响应报文</li></ul> <p><img src="/assets/img/http8.0f74b924.png" alt="http" title="http"></p> <ul><li>HTTP 响应报文例子</li></ul> <p><img src="/assets/img/http7.861cf9fb.png" alt="http" title="http"></p> <p><strong>5. 常用的请求报头</strong></p> <ul><li><code>Accept</code> 请求报头域用于指定客户端接受哪些类型的信息。</li></ul> <blockquote><p>注意，当我们在请求 JSON 接口时（JSON 接口是符合 RESTful 规范的），要指定 <strong>Accept:application/json</strong>，不然后端服务器那边无法正确返回数据。</p></blockquote> <ul><li><p><code>Accept-Charset</code> 请求报头域用于指定客户端接受的字符集。</p></li> <li><p><code>Accept-Encoding</code> 请求报头域类似于 Accept，但是它是用于指定可接受的内容编码。在服务端设定。</p></li> <li><p><code>Accept-Language</code> 请求报头域类似于 Accept，但是它是用于指定一种自然语言。在服务器设定。</p></li> <li><p><code>Authorization</code> 请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401(未授权)，可以发送一个包含Authorization 请求报头域的请求，要求服务器对其进行验证。</p></li> <li><p><code>Host</code> 请求报头域主要用于指定被请求资源的 Internet 主机和端口号，它通常从 HTTP URL 中提取出来的，发送请求时，该报头域是必需的。</p></li> <li><p><code>User-Agent</code> 请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</p></li> <li><p><code>Connection</code> 指定连接类型。keep-alive 是长连接。</p></li> <li><p><code>Referer</code> 用来表明当前页面的上一页是哪个页面。主要用来防盗链。</p></li></ul> <p><strong>6. 常用的响应报头</strong></p> <ul><li><p><code>Content-Type</code> 指定响应体的格式以及字符集编码是什么。</p></li> <li><p><code>Set-Cookie</code> 设置 cookie。</p></li></ul> <blockquote><p>客户端向服务器上传 cookie 是整块上传的，但是服务器向浏览器设置 cookie 是逐条设置的。一个完整的 cookie 应该是有5个字段的。</p></blockquote> <ul><li><p><code>Location</code> 响应报头域用于重定向接受者到一个新的位置。Location 响应报头域常用在更换域名的时候。</p></li> <li><p><code>Server</code> 响应报头域包含了服务器用来处理请求的软件信息。与 User-Agent 请求报头域是相对应的。</p></li> <li><p><code>WWW-Authenticate</code> 响应报头域必须被包含在401(未授权的)响应消息中，客户端收到 401 响应消息时候，并发送 Authorization 报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。</p></li></ul> <p><strong>7. 实体报头</strong></p> <p>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，<strong>但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域</strong>。实体报头定义了关于实体正文(eg:有无实体正文)和请求所标识的资源的元信息。</p> <ul><li><code>Content-Encoding</code> 实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得 Content-Type 报头域中所引用的媒体类型，必须采用相应的解码机制。</li></ul> <blockquote><p>Content-Encoding: gzip 标记着传输内容会被压缩，但是报头并不会被压缩。</p></blockquote> <ul><li><p><code>Content-Language</code> 实体报头域描述了资源所用的自然语言。</p></li> <li><p><code>Content-Length</code> 实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。</p></li> <li><p><code>Content-Type</code> 实体报头域用于指明发送给接收者的实体正文的媒体类型。</p></li> <li><p><code>Last-Modified</code> 实体报头域用于指示资源的最后修改日期和时间。</p></li> <li><p><code>Expires</code> 实体报头域给出响应过期的日期和时间。</p></li></ul> <h2 id="http-的请求方法"><a href="#http-的请求方法" class="header-anchor">#</a> HTTP 的请求方法</h2> <p>HTTP/1.0 定义了三种请求方法： GET、POST 和 HEAD 方法。</p> <p>HTTP/1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p> <p>具体可见：<a href="https://www.runoob.com/http/http-methods.html" target="_blank" rel="noopener noreferrer">HTTP 请求方法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>HTTP 常见的8种请求方法如下：</p> <ol><li><p><strong>GET</strong>: 请求获取 Request-URI 所标识的资源。</p></li> <li><p><strong>POST</strong>: 在 Request-URI 所标识的资源后附加新的数据。</p></li> <li><p><strong>HEAD</strong>: 请求获取由 Request-URI 所标识的资源的响应消息报头。</p></li> <li><p><strong>PUT</strong>: 请求服务器存储一个资源，并用 Request-URI 作为其标识。</p></li> <li><p><strong>DELETE</strong>: 请求服务器删除 Request-URI 所标识的资源。</p></li> <li><p><strong>TRACE</strong>: 请求服务器回送收到的请求信息，主要用于测试或诊断。</p></li> <li><p><strong>CONNECT</strong>: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p></li> <li><p><strong>OPTIONS</strong>: 请求查询服务器的性能，或者查询与资源相关的选项和需求。</p></li></ol> <p>以上的方法其实暗含了类似数据库的 CRUD 操作，CRUD 分别对应 PUT、GET、POST、DELETE。</p> <h2 id="http-状态码"><a href="#http-状态码" class="header-anchor">#</a> HTTP 状态码</h2> <p><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener noreferrer">HTTP 状态码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值:</p> <ol><li><p>1xx:指示信息--表示请求已接收，继续处理。</p></li> <li><p>2xx:成功--表示请求已被成功接收、理解、接受。</p></li> <li><p>3xx:重定向--要完成请求必须进行更进一步的操作。</p></li> <li><p>4xx:客户端错误--请求有语法错误或请求无法实现。</p></li> <li><p>5xx:服务器端错误--服务器未能实现合法的请求。</p></li></ol> <div class="custom-block tip"><p class="custom-block-title">推荐图书</p> <p><a href="https://item.jd.com/47379418374.html" target="_blank" rel="noopener noreferrer">学会提问系列图书<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <h2 id="cookie-与-session"><a href="#cookie-与-session" class="header-anchor">#</a> Cookie 与 Session</h2> <p>📌 <strong>什么是 Cookie</strong></p> <ol><li><p>Cookie 是<strong>保存在客户端的小段文本</strong>，随客户端点每一个请求发送该 url 下的所有 Cookie 到服务器端。</p></li> <li><p>Cookie 绝大多数情况下是<strong>产生在服务器端</strong>的，不过浏览器端也可以产生 Cookie。</p></li> <li><p>浏览器中有一个专门的文件是用来保存 Cookie 的，它保存在硬盘上。</p></li></ol> <p>📌 <strong>什么是 Session</strong></p> <ol><li><p>Session <strong>在服务器中生成，并且保存在服务器端</strong>，通过唯一的值 SessionID 来区别每一个用户。SessionID 随每个连接请求发送到服务器，服务器根据 SessionID 来识别客户端，再通过 Session 的 key 获取 Session 值。</p></li> <li><p>一般情况下，一个 Session 对应一个客户端。Session 里边是要保存数据的，并且里面的数据根据需要产生 Cookie，这样客户端和服务器就有一些共同的凭据，有了这些共同的凭据之后，就可以维护登录状态。</p></li> <li><p>Session 在服务器上是会过期的。</p></li></ol> <p>📌 <strong>Cookie 和 Session 的使用</strong></p> <ol><li><p>HTTP 是<strong>无状态协议</strong>，也就是说服务器不会维持客户端的连接状态。为什么不会维护呢？这是因为 HTTP 是建立在 TCP 之上的，TCP 可以维护客户端的连接状态。</p></li> <li><p>与 Cookie 相关的 HTTP 扩展头</p></li></ol> <ul><li><p>Cookie：客户端将服务器设置的 Cookie 返回到服务器。</p></li> <li><p>Set-Cookie：服务器向客户端设置 Cookie。</p></li></ul> <ol start="3"><li>服务器在响应消息中用 Set-Cookie 头将 Cookie 的内容回送给客户端，客户端在新的请求中将相同的内容携带在 Cookie 头中发送给服务器。从而实现会话的保持。</li></ol> <p><img src="/assets/img/http9.57630fa7.png" alt="http" title="http"></p> <ol start="4"><li>Cookie 和 Session 是需要配合使用的。下面就是它们的配合过程：</li></ol> <p><img src="/assets/img/http10.12aedf4e.png" alt="http" title="http"></p> <h2 id="http-的缓存机制"><a href="#http-的缓存机制" class="header-anchor">#</a> HTTP 的缓存机制</h2> <p>缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候，如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</p> <p>📌 <strong>缓存的优点</strong></p> <ul><li><p>减少相应延迟。</p></li> <li><p>减少网络带宽消耗。</p></li></ul> <div class="custom-block tip"><p class="custom-block-title">补充</p> <ol><li><p>在计算机里，速度最快的是 CPU，然后是内存，其次是在主板上的其他部件，比如硬盘。</p></li> <li><p>这些设备中，和浏览器相关的设备主要是 CPU、内存、显卡和网络设备。其中，网络是比较慢的，为了不让这些较慢的设备拖慢页面展示，所以就需要用缓存来提高速度。</p></li></ol></div> <p>📌 <strong>缓存的基本流程</strong></p> <p>浏览器首次发送请求时，服务器会返回资源。当浏览器再次请求时，服务器会先检查浏览器中是否有相关的缓存，如果有，则返回一个 304，让浏览器直接去缓存里取资源。</p> <p><img src="/assets/img/http11.c4c71cf3.png" alt="http" title="http"></p> <p>📌 <strong>浏览器缓存机制</strong></p> <p><img src="/assets/img/http12.a3541fed.png" alt="http" title="http"></p> <p><img src="/assets/img/http13.9430d999.png" alt="http" title="http"></p> <p>📌 <strong>两种缓存策略</strong></p> <ol><li>强制缓存</li></ol> <p>服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</p> <p><img src="/assets/img/http14.70ff536c.png" alt="http" title="http"></p> <ol start="2"><li>比较缓存（协商缓存）</li></ol> <p>将缓存信息中的 Etag 和 Last-Modified 通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p> <ul><li><strong>Etag/If-None-Match 策略</strong></li></ul> <p>（1）Etag：web 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识(生成规则由服务器决定)。</p> <p>（2）If-None-Match：当资源过期时(使用 Cache-Control 标识的 max-age)，发现资源具有 Etage 声明，则再次向 web 服务器请求时带上头 If-None-Match (Etag 的值)。web 服务器收到请求后发现有头 If-None-Match，则与被请求资源的相应校验串进行比对，决定返回200或304。</p> <ul><li><strong>Last-Modified/If-Modified-Since 策略</strong></li></ul> <p>（1）Last-Modified：标示这个响应资源的最后修改时间。web 服务器在响应请求时，告诉浏览器资源的最后修改时间。</p> <p>（2）If-Modified-Since：当资源过期时(使用 Cache-Control 标识的 max-age)，发现资源具有 Last-Modified 声明，则再次向 web 服务器请求时带上头 If- Modified-Since，表示请求时间。web 服务器收到请求后发现有头 If-Modified-Since，则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源有被改动过，则响应整片资源内容(写在响应消息包体内)HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的 cache。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/engineering/jenkins.html" class="prev">
        Jenkins 安装
      </a></span> <span class="next"><a href="/http/cryptography.html">
        密码学入门
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.83f3402d.js" defer></script><script src="/assets/js/2.a0a69aa9.js" defer></script><script src="/assets/js/9.698ca62a.js" defer></script>
  </body>
</html>
